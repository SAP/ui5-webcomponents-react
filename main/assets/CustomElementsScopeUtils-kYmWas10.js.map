{"version":3,"file":"CustomElementsScopeUtils-kYmWas10.js","sources":["../../node_modules/@ui5/webcomponents-base/dist/CustomElementsScopeUtils.js"],"sourcesContent":["import VersionInfo from \"./generated/VersionInfo.js\";\nlet suf;\nlet rulesObj = {\n    include: [/^ui5-/],\n    exclude: [],\n};\nconst tagsCache = new Map(); // true/false means the tag should/should not be cached, undefined means not known yet.\n/**\n * Sets the suffix to be used for custom elements scoping, f.e. pass \"demo\" to get tags such as \"ui5-button-demo\".\n * Note: by default all tags starting with \"ui5-\" will be scoped, unless you change this by calling \"setCustomElementsScopingRules\"\n *\n * @public\n * @param suffix The scoping suffix\n */\nconst setCustomElementsScopingSuffix = (suffix) => {\n    if (!suffix.match(/^[a-zA-Z0-9_-]+$/)) {\n        throw new Error(\"Only alphanumeric characters and dashes allowed for the scoping suffix\");\n    }\n    suf = suffix;\n};\n/**\n * Returns the currently set scoping suffix, or undefined if not set.\n *\n * @public\n * @returns {String|undefined}\n */\nconst getCustomElementsScopingSuffix = () => {\n    return suf;\n};\n/**\n * Sets the rules, governing which custom element tags to scope and which not, f.e.\n * setCustomElementsScopingRules({include: [/^ui5-/]}, exclude: [/^ui5-mylib-/, /^ui5-carousel$/]);\n * will scope all elements starting with \"ui5-\" but not the ones starting with \"ui5-mylib-\" and not \"ui5-carousel\".\n *\n * @public\n * @param rules Object with \"include\" and \"exclude\" properties, both arrays of regular expressions. Note that \"include\"\n * rules are applied first and \"exclude\" rules second.\n */\nconst setCustomElementsScopingRules = (rules) => {\n    if (!rules || !rules.include) {\n        throw new Error(`\"rules\" must be an object with at least an \"include\" property`);\n    }\n    if (!Array.isArray(rules.include) || rules.include.some(rule => !(rule instanceof RegExp))) {\n        throw new Error(`\"rules.include\" must be an array of regular expressions`);\n    }\n    if (rules.exclude && (!Array.isArray(rules.exclude) || rules.exclude.some(rule => !(rule instanceof RegExp)))) {\n        throw new Error(`\"rules.exclude\" must be an array of regular expressions`);\n    }\n    rules.exclude = rules.exclude || [];\n    rulesObj = rules;\n    tagsCache.clear(); // reset the cache upon setting new rules\n};\n/**\n * Returns the rules, governing which custom element tags to scope and which not. By default, all elements\n * starting with \"ui5-\" are scoped. The default rules are: {include: [/^ui5-/]}.\n *\n * @public\n * @returns {Object}\n */\nconst getCustomElementsScopingRules = () => {\n    return rulesObj;\n};\n/**\n * Determines whether custom elements with the given tag should be scoped or not.\n * The tag is first matched against the \"include\" rules and then against the \"exclude\" rules and the\n * result is cached until new rules are set.\n *\n * @public\n * @param tag\n */\nconst shouldScopeCustomElement = (tag) => {\n    if (!tagsCache.has(tag)) {\n        const result = rulesObj.include.some(rule => tag.match(rule)) && !rulesObj.exclude.some(rule => tag.match(rule));\n        tagsCache.set(tag, result);\n    }\n    return tagsCache.get(tag);\n};\n/**\n * Returns the currently set scoping suffix, if any and if the tag should be scoped, or undefined otherwise.\n *\n * @public\n * @param tag\n * @returns {String}\n */\nconst getEffectiveScopingSuffixForTag = (tag) => {\n    if (shouldScopeCustomElement(tag)) {\n        return getCustomElementsScopingSuffix();\n    }\n};\n/**\n * @public\n * Used for getting a scoped name for a CSS variable using the same transformation used in the build\n * @name the name of the css variable as written in the code\n * @returns a variable name with the current version inserted as available at runtime\n */\nconst getScopedVarName = (name) => {\n    const versionStr = `v${VersionInfo.version.replaceAll(\".\", \"-\")}`;\n    const expr = /(--_?ui5)([^,:)\\s]+)/g;\n    return name.replaceAll(expr, `$1-${versionStr}$2`);\n};\nexport { setCustomElementsScopingSuffix, getCustomElementsScopingSuffix, setCustomElementsScopingRules, getCustomElementsScopingRules, shouldScopeCustomElement, getEffectiveScopingSuffixForTag, getScopedVarName, };\n//# sourceMappingURL=CustomElementsScopeUtils.js.map"],"names":["suf","rulesObj","tagsCache","getCustomElementsScopingSuffix","shouldScopeCustomElement","tag","result","rule","getEffectiveScopingSuffixForTag","getScopedVarName","name","versionStr","VersionInfo","expr"],"mappings":"8CACA,IAAIA,EACAC,EAAW,CACX,QAAS,CAAC,OAAO,EACjB,QAAS,CAAE,CACf,EACA,MAAMC,EAAY,IAAI,IAoBhBC,EAAiC,IAC5BH,EA2CLI,EAA4BC,GAAQ,CACtC,GAAI,CAACH,EAAU,IAAIG,CAAG,EAAG,CACrB,MAAMC,EAASL,EAAS,QAAQ,KAAKM,GAAQF,EAAI,MAAME,CAAI,CAAC,GAAK,CAACN,EAAS,QAAQ,KAAKM,GAAQF,EAAI,MAAME,CAAI,CAAC,EAC/GL,EAAU,IAAIG,EAAKC,CAAM,CAC5B,CACD,OAAOJ,EAAU,IAAIG,CAAG,CAC5B,EAQMG,EAAmCH,GAAQ,CAC7C,GAAID,EAAyBC,CAAG,EAC5B,OAAOF,EAA8B,CAE7C,EAOMM,EAAoBC,GAAS,CAC/B,MAAMC,EAAa,IAAIC,EAAY,QAAQ,WAAW,IAAK,GAAG,CAAC,GACzDC,EAAO,wBACb,OAAOH,EAAK,WAAWG,EAAM,MAAMF,CAAU,IAAI,CACrD","x_google_ignoreList":[0]}